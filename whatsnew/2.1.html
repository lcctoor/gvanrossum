<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.1 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.1.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image" content="/static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="作者, A.M. Kuchling,. 概述: 本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Pytho..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Python 2.1 有什么新变化 &#8212; Python 3.12.3 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../static/documentation_options.js?v=67b2dffe"></script>
    <script src="../static/doctools.js?v=9a2dae69"></script>
    <script src="../static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../static/translations.js?v=beaddf03"></script>
    
    <script src="../static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.12.3 文档 中搜索"
          href="../static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 2.0 有什么新变化" href="2.0.html" />
    <link rel="prev" title="Python 2.2 有什么新变化" href="2.2.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.1.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../static/py.svg" />
            <script type="text/javascript" src="../static/copybutton.js"></script>
            <script type="text/javascript" src="../static/menu.js"></script>
            <script type="text/javascript" src="../static/search-focus.js"></script>
            <script type="text/javascript" src="../static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" />
                <input type="submit" value="提交"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.1 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指令</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 富比较</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告框架</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新的构建系统</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱引用</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 函数属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 在大小写不敏感的平台上导入模块</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 交互模式显示钩子</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新的强制转换模型</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Python 包中的元数据</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="上一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.0.html"
                          title="下一章">Python 2.0 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.1.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="Python 2.0 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.1 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-1">
<h1>Python 2.1 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-1" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>本文介绍了 Python 2.1 的新增特性。 虽然 2.1 的改变没有 Python 2.0 那么多，但是仍然有一些令人惊喜的东西。 2.1 是第一个使用 Python 增强提议，即 PEP 来进行引导的发行版，因此大部分重要的改变都有相应的 PEP 来提供有关改变的更完整文档和设计思路。 本文并未试图完整记录所有的新特性，而是为 Python 程序员提供新特性的简单概览。 请参阅 Python 2.1 文档，或特定的 PEP，获取针对你感兴趣的任何新特性的更多细节。</p>
<p>Python 开发团队的一个近期目标是加速新发行版的步调，使得每 6 到 9 个月就有一个新发行版。 2.1 是基于这个新步调推出的第一个发行版，第一个内测版将于一月发布，即 2.0 最终版发布 3 个月之后。</p>
<p>Python 2.1 的最终版本于2001年4月17日发布。</p>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: 嵌套的作用域<a class="headerlink" href="#pep-227-nested-scopes" title="Link to this heading">¶</a></h2>
<p>Python 2.1 中的最大改变是 Python 的作用域规则。 在 Python 2.0 中，任意给定的时刻至多使用三个命名空间来查找变量名称：局部、模块和内置命名空间。 这往往会导致令人吃惊的结果因为它与人们直觉上的预期不相匹配。 例如，一个嵌套的递归函数将不起作用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 总是会引发 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 异常，因为名称 <code class="docutils literal notranslate"><span class="pre">g</span></code> 的绑定既不在局部命名空间中也不在模块级命名空间中。 这在实践中不会有太大问题（你会经常这样递归地定义内部函数吗？），但是这也会让 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式的使用更为笨拙，这在实践中是有问题的。 在使用了 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 的代码中你经常能发现局部变量通过作为参数的默认值被拷贝。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>结果将会严重损害以高度函数式风格编写的 Python 代码的可读性。</p>
<p>Python 2.1 最显著的改变是增加了静态作用域这一语言特征来解决此问题。 作为它的第一项影响，在上述示例中的 <code class="docutils literal notranslate"><span class="pre">name=name</span></code> 默认参数现在将不再必要。 简单地说，当一个函数内部的给定变量名没有被赋值时（通过赋值语句，或者 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 或 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句），对该变量的引用将在外层作用域的局部命名空间中查找。 对于该规则的更详细解释，以及具体实现的分析，请参阅相应的 PEP。</p>
<p>对于同时在模块层级和包含下层函数定义的函数内部局部变量使用了相同变量名的代码来说这项改变可能会导致一些兼容性问题。 不过这看来不太可能发生，因为阅读这样的代码本来就会相当令人困惑。</p>
<p>此项改变的一个附带影响是在特定条件下函数作用域内部 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句将不允许使用。 Python 参考手册已经写明 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 仅在模块最高层级上是可用的，但此前 CPython 解释器从未强制实施此规则。 作为嵌套作用域具体实现的一部分，将 Python 源码转为字节码的编译器会生成不同的代码来访问某个包含作用域内的变量。 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会使得编译器无法正确执行，因为它们会向局部命名空间添加在编译时还不存在的名称。 为此，如果一个函数包含带有自由变量的函数定义或 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式，编译器将通过引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常来提示。</p>
<p>为了使前面的解释更清楚，下面是一个例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>包含 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句的第 4 行有语法错误，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 会定义一个名为 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的新局部变量，它的值应当被 <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> 所访问。</p>
<p>这应该不会是太大的限制，因为 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 在多数 Python 代码中都极少被使用（而当它被使用时，往往也是个存在糟糕设计的信号）。</p>
<p>由于兼容性问题，嵌套作用域被逐步引入；在 Python 2.1 中，它们默认未启用，但可以通过在模块中使用 future 语句来开启，如 <span class="target" id="index-33"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> 所述。 （参见下一节对 <span class="target" id="index-34"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> 的进一步讨论。）  在 Python 2.2 中，嵌套作用域将成为默认设置，并且无法关闭，但用户将有整个 2.1 版本的生命周期来修复因引入嵌套作用域而导致的任何问题。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-35"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a> - 静态嵌套作用域</dt><dd><p>由 Jeremy Hylton 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-236-future-directives">
<h2>PEP 236: __future__ 指令<a class="headerlink" href="#pep-236-future-directives" title="Link to this heading">¶</a></h2>
<p>对嵌套作用域的反应引起了广泛关注，人们担心在 Python 2.1 版本发布时会破坏现有代码，强烈的反应促使 Python 开发者采取了更保守的策略。这个策略包括引入一种约定，在版本 N 中启用可选功能，该功能将在版本 N+1 中成为强制功能。</p>
<p>语法使用 <code class="docutils literal notranslate"><span class="pre">from...import</span></code> 语句，使用保留模块名 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>。可以通过以下语句启用嵌套作用域：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">nested_scopes</span>
</pre></div>
</div>
<p>虽然它看起来像一个普通的 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句，但实际上并不是；关于此类 future 语句的位置有严格的规定。它们只能放在模块的顶部，必须位于任何 Python 代码或常规 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句之前。这是因为这样的语句会影响 Python 字节码编译器解析代码和生成字节码的方式，因此它们必须在任何会生成字节码的语句之前出现。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0236/"><strong>PEP 236</strong></a> - 回到 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a></dt><dd><p>由 Tim Peters 撰写，主要由 Jeremy Hylton 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-207-rich-comparisons">
<h2>PEP 207: 富比较<a class="headerlink" href="#pep-207-rich-comparisons" title="Link to this heading">¶</a></h2>
<p>在早期版本中，Python 对用户定义类和扩展类型的比较操作支持相当简单。类可以实现一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 方法，该方法接收两个类实例，并且只能返回 0 表示相等，或 +1 或 -1 表示不相等；该方法不能引发异常或返回布尔值以外的任何内容。Numeric Python 的用户经常发现这种模型太弱且受限，因为在 Numeric Python 所用的数字运算程序中，能够对两个矩阵进行逐元素比较更为有用，返回一个包含每个元素比较结果的矩阵。如果两个矩阵的大小不同，则比较必须能够引发异常以表示错误。</p>
<p>在 Python 2.1 中，为了支持这一需求，添加了丰富的比较操作。Python 类现在可以单独重载每一个 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>，<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>，<code class="docutils literal notranslate"><span class="pre">==</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!=</span></code> 操作。新的魔术方法名称如下：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>运算</p></th>
<th class="head"><p>方法名称</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p><a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>（这些魔术方法是以对应的 Fortran 操作符命名的，如 <code class="docutils literal notranslate"><span class="pre">.LT.</span></code>、<code class="docutils literal notranslate"><span class="pre">.LE.</span></code> 等。数值程序员几乎肯定对这些名称非常熟悉，并且会发现它们易于记忆。）</p>
<p>每个这样的魔术方法的形式都是 <code class="docutils literal notranslate"><span class="pre">method(self,</span> <span class="pre">other)</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">self</span></code> 是操作符左侧的对象，而 <code class="docutils literal notranslate"><span class="pre">other</span></code> 是操作符右侧的对象。例如，表达式 <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&lt;</span> <span class="pre">B</span></code> 会调用 <code class="docutils literal notranslate"><span class="pre">A.__lt__(B)</span></code>。</p>
<p>这些魔术方法可以返回任何类型的值：布尔值、矩阵、列表或任何其他 Python 对象。或者，如果比较是不可能的、不一致的或没有意义的，它们也可以引发异常。</p>
<p>内置的 <code class="docutils literal notranslate"><span class="pre">cmp(A,B)</span></code> 函数可以使用丰富的比较机制，现在接受一个可选参数来指定要使用的比较操作；该参数可以是字符串 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&lt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;&gt;=&quot;</span></code>、<code class="docutils literal notranslate"><span class="pre">&quot;==&quot;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&quot;!=&quot;</span></code> 之一。如果不带可选的第三个参数调用，<code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code> 函数将只返回 -1、0 或 +1，就像以前的 Python 版本一样；否则，它将调用适当的方法并可以返回任何 Python 对象。</p>
<p>对于 C 程序员来说，也有相应的变更；类型对象中有一个新的槽 <code class="docutils literal notranslate"><span class="pre">tp_richcmp</span></code> 以及一个用于执行指定丰富比较的 API。这里我不会涉及 C API 的具体内容，完整的相关函数列表请参阅 <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a> 或 2.1 的 C API 文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0207/"><strong>PEP 207</strong></a> - 富比较</dt><dd><p>由 Guido van Rossum 编写，大量参考 David Ascher 的先期工作，并由 Guido van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-230-warning-framework">
<h2>PEP 230: 警告框架<a class="headerlink" href="#pep-230-warning-framework" title="Link to this heading">¶</a></h2>
<p>在过去的10年中，Python积累了一定数量的过时模块和功能。由于无法确切知道某个功能被使用的程度：可能没有程序依赖该功能，也可能有很多程序依赖，因此很难确定何时可以安全地移除某个功能，为了以更结构化的方式移除旧功能，添加了一个警告框架。当Python开发者想要废弃某个功能时，它会在下一个Python版本中首先触发一个警告。然后，在随后的Python版本中可以移除该功能，这样用户将有一个完整的发布周期来删除对旧功能的使用。</p>
<p>Python 2.1 增加了警告框架以用于此方案。 它增加了一个 <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块，该模块提供了发出警告的函数，以及过滤掉不想显示的警告的功能。 第三方模块也可以使用这个框架来弃用它们不再希望支持的旧功能。</p>
<p>例如，在 Python 2.1 中，<code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用，因此导入它会打印出一个警告：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regex</span>
<span class="go">__main__:1: DeprecationWarning: the regex module</span>
<span class="go">         is deprecated; please use the re module</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>警告可以通过调用 <a class="reference internal" href="../library/warnings.html#warnings.warn" title="warnings.warn"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.warn()</span></code></a> 函数来发出:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;feature X no longer supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>第一个形参是警告消息；额外的可选形参可被用来指定一个专门的警告类别。</p>
<p>可以添加过滤器来禁用某些警告；可以将正则表达式模式应用于消息或模块名称，以抑制警告。例如，你可能有一个使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块的程序，并且暂时不想花时间将其转换为使用 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块。可以通过调用以下代码来抑制警告：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="s1">&#39;.*regex module is deprecated&#39;</span><span class="p">,</span>
                        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这添加了一个过滤器，该过滤器仅适用于在 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 模块中触发的 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 类警告，并应用一个正则表达式来仅匹配有关 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 模块已被弃用的消息，这将导致忽略此类警告。警告还可以仅打印一次，每次执行违规代码时打印，或者转换为异常，从而导致程序停止（当然，除非以常规方式捕获这些异常）。</p>
<p>Python的C API也增加了用于发出警告的函数；详情请参阅PEP 230或Python的API文档。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0005/"><strong>PEP 5</strong></a> - 语言演化的准则</dt><dd><p>该文档由Paul Prescod撰写，旨在规定移除Python旧功能时应遵循的程序。尽管本文描述的政策尚未被正式采纳，但最终的政策可能不会与Prescod的提议有太大不同。</p>
</dd>
<dt><span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0230/"><strong>PEP 230</strong></a> - 警告框架</dt><dd><p>由 Guido van Rossum 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-229-new-build-system">
<h2>PEP 229: 新的构建系统<a class="headerlink" href="#pep-229-new-build-system" title="Link to this heading">¶</a></h2>
<p>在编译 Python 时，用户必须进入并编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件以启用各种附加模块；默认集相对较小，并且仅限于在大多数 Unix 平台上编译的模块。这意味着在具有更多功能的 Unix 平台上，特别是 Linux，Python 安装通常不包含所有可能有用的模块。</p>
<p>Python 2.0 添加了 Distutils，一组用于分发和安装扩展模块的模块。在 Python 2.1 中，Distutils 被用于编译大部分标准库扩展模块，自动检测当前机器上支持哪些模块。希望这将使 Python 的安装更加容易并具有更多功能。</p>
<p>不再需要编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件来启用模块，而是在 Python 源代码分发包的顶层目录运行一个 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本，该脚本在构建时尝试通过检查系统上的模块和头文件来发现可以启用那些模块。 如果某个模块已在 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 中配置，则 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 脚本不会尝试编译该模块，并会遵从 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 文件中的内容。 这提供了一种方式来指定特定平台所需的任何奇怪的命令行标志或库。</p>
<p>在对构建机制的另一项重大更改中，Neil Schemenauer 对其进行了重组，现在 Python 使用单一的非递归 makefile，而不是在顶层目录和 <code class="file docutils literal notranslate"><span class="pre">Python/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Parser/</span></code>、<code class="file docutils literal notranslate"><span class="pre">Objects/`和</span> <span class="pre">:file:`Modules/</span></code> 子目录中的多个 makefile。这使得构建 Python 更快，同时也使修改 Makefile 更加清晰和简单。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0229/"><strong>PEP 229</strong></a> - 使用 Distutils 来构建 Python</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-205-weak-references">
<h2>PEP 205: 弱引用<a class="headerlink" href="#pep-205-weak-references" title="Link to this heading">¶</a></h2>
<p>弱引用，通过 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块提供，是 Python 程序员工具箱中一种较小但有用的新数据类型。</p>
<p>存储对对象的引用（例如，在字典或列表中）会导致该对象永久存活。在某些特定情况下，这种行为是不希望的，最常见的是对象缓存，另一个是像树这样的数据结构中的循环引用。</p>
<p>例如，考虑一个记忆化函数，它通过将函数的参数及其结果存储在字典中来缓存另一个函数 <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 的结果：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache the returned object</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>这个版本适用于诸如整数之类的简单对象，但它有一个副作用；<code class="docutils literal notranslate"><span class="pre">_cache</span></code> 字典持有返回值的引用，因此这些值在 Python 进程退出并清理之前永远不会被释放。对于整数，这不是很明显，但如果 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> 返回一个对象或占用大量内存的数据结构，这可能会成为一个问题。</p>
<p>弱引用提供了一种实现缓存的方法，不会让对象在其生命周期结束后仍然存活。如果一个对象仅通过弱引用访问，该对象将被释放，并且弱引用将指示它所引用的对象不再存在。通过调用 <code class="docutils literal notranslate"><span class="pre">wr</span> <span class="pre">=</span> <span class="pre">weakref.ref(obj)</span></code> 来创建对对象 <em>obj</em> 的弱引用。通过调用弱引用，就像调用函数一样，可以返回被引用的对象：<code class="docutils literal notranslate"><span class="pre">wr()</span></code>。如果对象仍然存在，它将返回被引用的对象；如果对象不再存在，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>This makes it possible to write a <code class="xref py py-func docutils literal notranslate"><span class="pre">memoize()</span></code> function whose cache doesn't
keep objects alive, by storing weak references in the cache.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]()</span>
        <span class="c1"># If weak reference object still exists,</span>
        <span class="c1"># return it</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">obj</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache a weak reference</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> module also allows creating proxy objects which behave like
weak references --- an object referenced only by proxy objects is deallocated --
but instead of requiring an explicit call to retrieve the object, the proxy
transparently forwards all operations to the object as long as the object still
exists.  If the object is deallocated, attempting to use a proxy will cause a
<code class="xref py py-exc docutils literal notranslate"><span class="pre">weakref.ReferenceError</span></code> exception to be raised.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># Equivalent to obj.attr</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span> <span class="c1"># Equivalent to obj.meth()</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># raises weakref.ReferenceError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0205/"><strong>PEP 205</strong></a> - 弱引用</dt><dd><p>由 Fred L. Drake, Jr 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-232-function-attributes">
<h2>PEP 232: 函数属性<a class="headerlink" href="#pep-232-function-attributes" title="Link to this heading">¶</a></h2>
<p>In Python 2.1, functions can now have arbitrary information attached to them.
People were often using docstrings to hold information about functions and
methods, because the <a class="reference internal" href="../reference/datamodel.html#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> attribute was the only way of
attaching any
information to a function.  For example, in the Zope web application server,
functions are marked as safe for public access by having a docstring, and in
John Aycock's SPARK parsing framework, docstrings hold parts of the BNF grammar
to be parsed.  This overloading is unfortunate, since docstrings are really
intended to hold a function's documentation; for example, it means you can't
properly document functions intended for private use in Zope.</p>
<p>现在可以使用常规的 Python 语法在函数上设置和检索任意属性：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>

<span class="n">f</span><span class="o">.</span><span class="n">publish</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">secure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="s2">&quot;A ::= B (C D)*&quot;</span>
</pre></div>
</div>
<p>The dictionary containing attributes can be accessed as the function's
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. Unlike the <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute of class instances, in
functions you can actually assign a new dictionary to <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, though
the new value is restricted to a regular Python dictionary; you <em>can't</em> be
tricky and set it to a <code class="xref py py-class docutils literal notranslate"><span class="pre">UserDict</span></code> instance, or any other random object
that behaves like a mapping.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0232/"><strong>PEP 232</strong></a> - 函数属性</dt><dd><p>由 Barry Warsaw 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-235-importing-modules-on-case-insensitive-platforms">
<h2>PEP 235: 在大小写不敏感的平台上导入模块<a class="headerlink" href="#pep-235-importing-modules-on-case-insensitive-platforms" title="Link to this heading">¶</a></h2>
<p>Some operating systems have filesystems that are case-insensitive, MacOS and
Windows being the primary examples; on these systems, it's impossible to
distinguish the filenames <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code> and <code class="docutils literal notranslate"><span class="pre">file.py</span></code>, even though they do store
the file's name  in its original case (they're case-preserving, too).</p>
<p>In Python 2.1, the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement will work to simulate case-sensitivity
on case-insensitive platforms.  Python will now search for the first
case-sensitive match by default, raising an <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> if no such file
is found, so <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">file</span></code> will not import a module named <code class="docutils literal notranslate"><span class="pre">FILE.PY</span></code>.
Case-insensitive matching can be requested by setting the <span class="target" id="index-11"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONCASEOK</span></code></a>
environment variable before starting the Python interpreter.</p>
</section>
<section id="pep-217-interactive-display-hook">
<h2>PEP 217: 交互模式显示钩子<a class="headerlink" href="#pep-217-interactive-display-hook" title="Link to this heading">¶</a></h2>
<p>When using the Python interpreter interactively, the output of commands is
displayed using the built-in <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> function. In Python 2.1, the variable
<a class="reference internal" href="../library/sys.html#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.displayhook()</span></code></a> can be set to a callable object which will be called
instead of <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>. For example, you can set it to a special
pretty-printing function:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a recursive data structure</span>
<span class="gp">... </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="c1"># Show Python&#39;s default output</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use pprint.pprint() as the display function</span>
<span class="gp">... </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">displayhook</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[1, 2, 3,  &lt;Recursion on list with id=135143996&gt;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0217/"><strong>PEP 217</strong></a> - 用于交互模式的显示钩子</dt><dd><p>由 Moshe Zadka 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-208-new-coercion-model">
<h2>PEP 208: 新的强制转换模型<a class="headerlink" href="#pep-208-new-coercion-model" title="Link to this heading">¶</a></h2>
<p>在 C 级别上的数值类型转换方法进行了重大修改。这只会影响编写 Python C 扩展的作者，使他们在编写支持数值运算的扩展类型时有更多的灵活性。</p>
<p>Extension types can now set the type flag <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code> in their
<code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> structure to indicate that they support the new coercion model.
In such extension types, the numeric slot functions can no longer assume that
they'll be passed two arguments of the same type; instead they may be passed two
arguments of differing types, and can then perform their own internal coercion.
If the slot function is passed a type it can't handle, it can indicate the
failure by returning a reference to the <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code> singleton value.
The numeric functions of the other type will then be tried, and perhaps they can
handle the operation; if the other type also returns <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>, then
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> will be raised.  Numeric methods written in Python can also
return <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>, causing the interpreter to act as if the method
did not exist (perhaps raising a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, perhaps trying another
object's numeric methods).</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0208/"><strong>PEP 208</strong></a> - 改写强制转换模型</dt><dd><p>由 Neil Schemenauer 编写和实现，基于 Marc-André Lemburg 的早期工作。阅读这部分内容可以了解数值运算在 C 级别上现在如何处理的细节。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-241-metadata-in-python-packages">
<h2>PEP 241: Python 包中的元数据<a class="headerlink" href="#pep-241-metadata-in-python-packages" title="Link to this heading">¶</a></h2>
<p>A common complaint from Python users is that there's no single catalog of all
the Python modules in existence.  T. Middleton's Vaults of Parnassus at
<code class="docutils literal notranslate"><span class="pre">www.vex.net/parnassus/</span></code> (retired in February 2009, <a class="reference external" href="https://web.archive.org/web/20090130140102/http://www.vex.net/parnassus/">available in the
Internet Archive Wayback Machine</a>)
was the largest catalog of Python modules, but
registering software at the Vaults is optional, and many people did not bother.</p>
<p>As a first small step toward fixing the problem, Python software packaged using
the Distutils <strong class="command">sdist</strong> command will include a file named
<code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> containing information about the package such as its name,
version, and author (metadata, in cataloguing terminology).  <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a> contains
the full list of fields that can be present in the <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> file.  As
people began to package their software using Python 2.1, more and more packages
will include metadata, making it possible to build automated cataloguing systems
and experiment with them.  With the result experience, perhaps it'll be possible
to design a really good catalog and then build support for it into Python 2.2.
For example, the Distutils <strong class="command">sdist</strong> and <strong class="command">bdist_*</strong> commands
could support an <code class="docutils literal notranslate"><span class="pre">upload</span></code> option that would automatically upload your
package to a catalog server.</p>
<p>You can start creating packages containing <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> even if you're not
using Python 2.1, since a new release of the Distutils will be made for users of
earlier Python versions.  Version 1.0.2 of the Distutils includes the changes
described in <span class="target" id="index-15"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a>, as well as various bugfixes and enhancements.  It will be
available from the Distutils SIG at <a class="reference external" href="https://www.python.org/community/sigs/current/distutils-sig/">https://www.python.org/community/sigs/current/distutils-sig/</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0241/"><strong>PEP 241</strong></a> - 针对 Python 软件包的元数据</dt><dd><p>由 A.M. Kuchling 撰写并实现。</p>
</dd>
<dt><span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0243/"><strong>PEP 243</strong></a> - 模块仓库上传机制</dt><dd><p>由 Sean Reifschneider 撰写，这个 PEP 草案描述了用于将 Python 软件包上传到一个中心服务器的建议机制。</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<ul>
<li><p>Ka-Ping Yee contributed two new modules: <code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect.py</span></code>, a module for
getting information about live Python code, and <code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code>, a module for
interactively converting docstrings to HTML or text.  As a bonus,
<code class="file docutils literal notranslate"><span class="pre">Tools/scripts/pydoc</span></code>, which is now automatically installed, uses
<code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc.py</span></code> to display documentation given a Python module, package, or
class name.  For example, <code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">xml.dom</span></code> displays the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">Library</span> <span class="n">Documentation</span><span class="p">:</span> <span class="n">package</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">xml</span>

<span class="n">NAME</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="o">-</span> <span class="n">W3C</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">Python</span><span class="o">.</span>

<span class="n">FILE</span>
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="mf">.1</span><span class="o">/</span><span class="n">xml</span><span class="o">/</span><span class="n">dom</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>

<span class="n">DESCRIPTION</span>
    <span class="n">The</span> <span class="n">Python</span> <span class="n">mapping</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">documented</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="n">Python</span> <span class="n">Library</span> <span class="n">Reference</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">section</span> <span class="n">on</span> <span class="n">the</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="n">package</span><span class="o">.</span>

    <span class="n">This</span> <span class="n">package</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">following</span> <span class="n">modules</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">pydoc</span></code> also includes a Tk-based interactive help browser.   <code class="file docutils literal notranslate"><span class="pre">pydoc</span></code>
quickly becomes addictive; try it out!</p>
</li>
<li><p>Two different modules for unit testing were added to the standard library.
The <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> module, contributed by Tim Peters, provides a testing
framework based on running embedded examples in docstrings and comparing the
results against the expected output.  PyUnit, contributed by Steve Purcell, is a
unit testing framework inspired by JUnit, which was in turn an adaptation of
Kent Beck's Smalltalk testing framework.  See <a class="reference external" href="https://pyunit.sourceforge.net/">https://pyunit.sourceforge.net/</a> for
more information about PyUnit.</p></li>
<li><p>The <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> module contains a class, <a class="reference internal" href="../library/difflib.html#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>, which
compares two sequences and computes the changes required to transform one
sequence into the other.  For example, this module can be used to write a tool
similar to the Unix <strong class="program">diff</strong> program, and in fact the sample program
<code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ndiff.py</span></code> demonstrates how to write such a script.</p></li>
<li><p><a class="reference internal" href="../library/curses.panel.html#module-curses.panel" title="curses.panel: A panel stack extension that adds depth to  curses windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses.panel</span></code></a>, a wrapper for the panel library, part of ncurses and of
SYSV curses, was contributed by Thomas Gellekum.  The panel library provides
windows with the additional feature of depth. Windows can be moved higher or
lower in the depth ordering, and the panel library figures out where panels
overlap and which sections are visible.</p></li>
<li><p>The PyXML package has gone through a few releases since Python 2.0, and Python
2.1 includes an updated version of the <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package.  Some of the
noteworthy changes include support for Expat 1.2 and later versions, the ability
for Expat parsers to handle files in any encoding supported by Python, and
various bugfixes for SAX, DOM, and the <code class="xref py py-mod docutils literal notranslate"><span class="pre">minidom</span></code> module.</p></li>
<li><p>Ping also contributed another hook for handling uncaught exceptions.
<a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a> can be set to a callable object.  When an exception isn't
caught by any <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> blocks, the exception will be
passed to <a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.excepthook()</span></code></a>, which can then do whatever it likes.  At the
Ninth Python Conference, Ping demonstrated an application for this hook:
printing an extended traceback that not only lists the stack frames, but also
lists the function arguments and the local variables for each frame.</p></li>
<li><p>Various functions in the <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module, such as <a class="reference internal" href="../library/time.html#time.asctime" title="time.asctime"><code class="xref py py-func docutils literal notranslate"><span class="pre">asctime()</span></code></a> and
<a class="reference internal" href="../library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a>, require a floating point argument containing the time in
seconds since the epoch.  The most common use of these functions is to work with
the current time, so the floating point argument has been made optional; when a
value isn't provided, the current time will be used.  For example, log file
entries usually need a string containing the current time; in Python 2.1,
<code class="docutils literal notranslate"><span class="pre">time.asctime()</span></code> can be used, instead of the lengthier
<code class="docutils literal notranslate"><span class="pre">time.asctime(time.localtime(time.time()))</span></code> that was previously required.</p>
<p>此更改由 Thomas Wouters 提出并实现。</p>
</li>
<li><p>The <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> module now defaults to retrieving files in passive mode,
because passive mode is more likely to work from behind a firewall.  This
request came from the Debian bug tracking system, since other Debian packages
use <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> to retrieve files and then don't work from behind a firewall.
It's deemed unlikely that this will cause problems for anyone, because Netscape
defaults to passive mode and few people complain, but if passive mode is
unsuitable for your application or network setup, call <code class="docutils literal notranslate"><span class="pre">set_pasv(0)</span></code> on
FTP objects to disable passive mode.</p></li>
<li><p>Support for raw socket access has been added to the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module,
contributed by Grant Edwards.</p></li>
<li><p>The <a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> module now contains a simple interactive statistics browser
for displaying timing profiles for Python programs, invoked when the module is
run as a script.  Contributed by  Eric S. Raymond.</p></li>
<li><p>A new implementation-dependent function, <code class="docutils literal notranslate"><span class="pre">sys._getframe([depth])</span></code>, has
been added to return a given frame object from the current call stack.
<a class="reference internal" href="../library/sys.html#sys._getframe" title="sys._getframe"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._getframe()</span></code></a> returns the frame at the top of the call stack;  if the
optional integer argument <em>depth</em> is supplied, the function returns the frame
that is <em>depth</em> calls below the top of the stack.  For example,
<code class="docutils literal notranslate"><span class="pre">sys._getframe(1)</span></code> returns the caller's frame object.</p>
<p>这个函数仅存在于 CPython 中，不存在于 Jython 或 .NET 实现中。请将其用于调试，并避免将其放入生产代码中。</p>
</li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p>由于较短的发布周期，Python 2.1 中的较小更改相对较少。通过搜索 CVS 更改日志，发现应用了 117 个补丁并修复了 136 个错误；这两个数字都可能是低估的。一些较为显著的更改包括：</p>
<ul>
<li><p>A specialized object allocator is now optionally available, that should be
faster than the system <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and have less memory overhead.  The
allocator uses C's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> function to get large pools of memory, and
then fulfills smaller memory requests from these pools.  It can be enabled by
providing the <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> option to the <strong class="program">configure</strong>
script; see <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code> for the implementation details.</p>
<p>Authors of C extension modules should test their code with the object allocator
enabled, because some incorrect code may break, causing core dumps at runtime.
There are a bunch of memory allocation functions in Python's C API that have
previously been just aliases for the C library's <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>, meaning that if you accidentally called mismatched functions, the
error wouldn't be noticeable.  When the object allocator is enabled, these
functions aren't aliases of <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> any more, and
calling the wrong function to free memory will get you a core dump.  For
example, if memory was allocated using <a class="reference internal" href="../c-api/memory.html#c.PyMem_New" title="PyMem_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMem_New</span></code></a>, it has to be freed
using <a class="reference internal" href="../c-api/memory.html#c.PyMem_Del" title="PyMem_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Del()</span></code></a>, not <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.  A few modules included with Python
fell afoul of this and had to be fixed; doubtless there are more third-party
modules that will have the same problem.</p>
<p>对象分配器由 Vladimir Marangozov 贡献。</p>
</li>
<li><p>The speed of line-oriented file I/O has been improved because people often
complain about its lack of speed, and because it's often been used as a naïve
benchmark.  The <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> method of file objects has therefore been
rewritten to be much faster.  The exact amount of the speedup will vary from
platform to platform depending on how slow the C library's <code class="xref c c-func docutils literal notranslate"><span class="pre">getc()</span></code> was, but
is around 66%, and potentially much faster on some particular operating systems.
Tim Peters did much of the benchmarking and coding for this change, motivated by
a discussion in comp.lang.python.</p>
<p>A new module and method for file objects was also added, contributed by Jeff
Epler. The new method, <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code>, is similar to the existing
<code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> built-in.  <code class="xref py py-func docutils literal notranslate"><span class="pre">xreadlines()</span></code> returns an opaque sequence object
that only supports being iterated over, reading a line on every iteration but
not reading the entire file into memory as the existing <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> method
does. You'd use it like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">xreadlines</span><span class="p">():</span>
    <span class="c1"># ... do something for each line ...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>有关行 I/O 更改的更详细讨论，请参阅 2001 年 1 月 1 日至 15 日的 python-dev 摘要：<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-January/">https://mail.python.org/pipermail/python-dev/2001-January/</a> 。</p>
</li>
<li><p>A new method, <a class="reference internal" href="../library/stdtypes.html#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a>, was added to dictionaries to enable
destructively iterating through the contents of a dictionary; this can be faster
for large dictionaries because there's no need to construct a list containing
all the keys or values. <code class="docutils literal notranslate"><span class="pre">D.popitem()</span></code> removes a random <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pair
from the dictionary <code class="docutils literal notranslate"><span class="pre">D</span></code> and returns it as a 2-tuple.  This was implemented
mostly by Tim Peters and Guido van Rossum, after a suggestion and preliminary
patch by Moshe Zadka.</p></li>
<li><p>Modules can now control which names are imported when <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>
is used, by defining an <code class="docutils literal notranslate"><span class="pre">__all__</span></code> attribute containing a list of names that
will be imported.  One common complaint is that if the module imports other
modules such as <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> or <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> will add
them to the importing module's namespace.  To fix this, simply list the public
names in <code class="docutils literal notranslate"><span class="pre">__all__</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># List public names</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Database&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>此补丁的更严格版本最初由 Ben Wolfson 提出并实现，但在经过一些 python-dev 讨论后，最终版本被修改为较弱的版本并提交。</p>
</li>
<li><p>Applying <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> to strings previously used octal escapes for
non-printable characters; for example, a newline was <code class="docutils literal notranslate"><span class="pre">'\012'</span></code>.  This was a
vestigial trace of Python's C ancestry, but today octal is of very little
practical use.  Ka-Ping Yee suggested using hex escapes instead of octal ones,
and using the <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\t</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code> escapes for the appropriate characters,
and implemented this new formatting.</p></li>
<li><p>在编译时检测到的语法错误现在可以引发包含错误文件名和行号的异常，这是 Jeremy Hylton 进行的编译器重组的一个令人愉快的副作用。</p></li>
<li><p>C extensions which import other modules have been changed to use
<a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>, which means that they will use any import hooks
that have been installed.  This is also encouraged for third-party extensions
that need to import some other module from C code.</p></li>
<li><p>由于 Fredrik Lundh 的努力，Unicode 字符数据库的大小又减少了 340K。</p></li>
<li><p>一些新移植版本被贡献：MacOS X（由 Steven Majewski 贡献），Cygwin（由 Jason Tishler 贡献），RISCOS（由 Dietmar Schwertberger 贡献），以及 Unixware 7（由 Billy G. Allie 贡献）。</p></li>
</ul>
<p>此外还有一份由次要的程序错误修复、次要的内存泄漏、文档字符串编辑和其他调整组成的常规清单，因过于冗长而不值得逐项列出；如果你想了解完整细节请参阅 CVS 日志。</p>
</section>
<section id="acknowledgements">
<h2>致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p>作者感谢以下人员对本文的各种草案提出建议： Graeme Cross, David Goodger, Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.1 有什么新变化</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 嵌套的作用域</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指令</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 富比较</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告框架</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新的构建系统</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱引用</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 函数属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 在大小写不敏感的平台上导入模块</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 交互模式显示钩子</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新的强制转换模型</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Python 包中的元数据</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="上一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.0.html"
                          title="下一章">Python 2.0 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.1.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="Python 2.0 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.3 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.1 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box" />
          <input type="submit" value="提交" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版权所有
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最后更新于 May 31, 2024 (10:14 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    由 <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7创建。
    </div>

  </body>
</html>